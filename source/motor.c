/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
*/

#include "motor.h"
#include "utils.h"
#include "debug.h"
#include "hwconfig.h"
#include "encoder.h"
#include "time.h"
#include <math.h>

/* Add a link to the HB25 data sheet
   Ref: https://www.parallax.com/sites/default/files/downloads/HB-25-Motor-Controller-Guide-v1.3.pdf
 */

#define HB25_ENABLE_BIT (0)
#define HB25_PWM_BIT (1)
#define HB25_ENABLE (0)
#define HB25_DISABLE (1)

/* Note: While technically the motors are reverse relative to each other, it is clearer to hide this difference from
   the code.  Therefore, while the pwm values will be different, for a code perspective the functionality will be the 
   same between the boards driving the motors.  For example, the pwm constants refer to forward and reverse even though
   the actual values are different and the motors are moving oppositely.

                            Left    Right
        PWM_FULL_FORWARD |  2000  | 1000  |
        PWM_STOP         |  1500  | 1500  |
        PWM_FULL_REVERSE |  1000  | 2000  |
        PWM_DECREMENT    |   -1   |   1   |
        PWM_INCREMENT    |    1   |  -1   |
        PWM_CAL_STEP     |   10   |  10   |
        PWM_MIN          |  2000  | 1500  |
        PWM_MAX          |  1500  | 1000  |
 */

#ifdef LEFT_BOARD
/* Per the HB-25 data sheet: 
	1.0 ms Full Reverse 
	1.5 ms Neutral (Off) 
    2.0 ms Full Forward
    
   Note: The datasheet is in error, it should be 1000 ms, 1500 ms and 2000 ms
 */
#define PWM_FULL_FORWARD (2000)
#define PWM_STOP         (1500)
#define PWM_FULL_REVERSE (1000)
#define PWM_DECREMENT    (-1)
#define PWM_INCREMENT    (1)
#define PWM_MIN          (PWM_FULL_FORWARD)
#define PWM_MAX          (PWM_STOP)
    
/* Calibration is performed only in the forward direction.  This gives a mapping between count/sec and pwm values. It is
   assumed that motor movement is symetric about the stop pwm between forward and reverse.  Therefore, the cps-to-pwm
   mapping generated by calibration in the forward direction can be used for generating reverse motion.  This safe space
   and time during calibration.
    
    If the direction is forward (positive) then index the array using cps.  
    If the direction is reverse (negative) then reflect the pwm selected by cps onto the reverse side as follows:
    
            delta = 1600 - 1500 = 100
            reverse pwm = 1500 - delta
    
       1000                            1500                           2000
         |                               |                              |
    |-------------------------------------------------------------------------|
                                |                  |
                                |                 cps yields 1600
                  corresponding reverse value
                              1400
    
    More generally, 2 * PWM_STOP - pwm
    
 */
#define PWM_REFLECT(mms, pwm) ((mms < 0) ? 2 * PWM_STOP - pwm : pwm)
#elif defined RIGHT_BOARD
#define PWM_FULL_FORWARD (1000)
#define PWM_STOP         (1500)
#define PWM_FULL_REVERSE (2000)
#define PWM_DECRMENT     (1)
#define PWM_INCREMENT    (-1)
#define PWM_MIN          (PWM_STOP)
#define PWM_MAX          (PWM_FULL_FORWARD)
#define PWM_REFLECT(mms, pwm) ((mms < 0) ? 2 * PWM_STOP + pwm : pwm)
#else
    #error "You haven't defined a board, e.g. LEFT_BOARD or RIGHT_BOARD"
#endif

#define PWM_RANGE        (500) // 2000 - 1500 = 500, 1500 - 1000 = 500

// Empirical step value that balances time, space, and accuracy
#define PWM_CAL_STEP     (10)
/* Empirical values to allow the pwm to settle.  Probably not particularly relevant since the pwm is done via hardware
   but it doesn't hurt (just adds little more time to calibration
 */
#define PWM_SETTLE_TIME  (1000)

/* 
    Calibration Constants

    Number of entries depends on the range and step size, e.g., smaller step more values and vice versa
 */
#define MAX_NUM_CAL_ENTRY (PWM_RANGE/PWM_CAL_STEP)
#define MIN_CAL_ENTRY (0)
#define MAX_CAL_ENTRY (MAX_NUM_CAL_ENTRY - 1)

/* The number of samples to take when measuring speed */
#define MAX_SPEED_SAMPLES (5)

#define CAL_PWM_START (PWM_FULL_FORWARD)
#define CAL_PWM_END (PWM_STOP)
#define CAL_PWM_STEP (PWM_DECREMENT*PWM_CAL_STEP)

#define CAL_VAL_CPS_START (20)
#define CAL_VAL_STEP (10)
#define CAL_VAL_NUM_SAMPLES (2)
#define CAL_VAL_SAMPLE_PERIOD (250) // milliseconds

/* Structure used to capture pwm and cps samples during calibration
 */
typedef struct
{
    int16 cps;
    uint16 pwm;
} CALIBRATION_ENTRY;

/* Mapping between count/sec and pwm derived during calibration
 */
static CALIBRATION_ENTRY cal_cps_to_pwm[MAX_NUM_CAL_ENTRY];

/* Count/Second to PWM Map

    Per the motor specification (https://www.parallax.com/product/28962):
        Approx. Max Speed: 95 RPM (1.53 RPS)
        Encoder Resolution: 36 position (quadrature encoding yields 144 counts per revolution)
        Wheel Circumference: 479 mm

    From the above, the motor has a max count/sec of 228 and max speed of 733 mm/s.  
    Empirical measurement gives a usable range of 0 .. 200 count/s and 655 mm/s.  Typically, the calibration captures a
    max count/sec between 180-190.  Your mileage may vary :-)

 */
#define MIN_CPS_VALUE (1)
#define MAX_CPS_VALUE (200)

#define MAX_NUM_CPS_ENTRY (MAX_CPS_VALUE)
#define MIN_CPS_ENTRY (0)
#define MAX_CPS_ENTRY (MAX_NUM_CPS_ENTRY - 1)


/* Note: The following array contains entries that were derived during calibration.  These values are specific to
   a particular wheel, encoder, and motor driver and stored in flash so there are defaults.  Calibration allows these 
   values to be updated and stored on the Raspberry Pi, and uploaded on startup which will allow for electrical and 
   mechanical differences.
 */
static uint16 map_cps_to_pwm[MAX_NUM_CPS_ENTRY] = {1500, 1504, 1508, 1512, 1516, 1520, 1524, 1528, 1532, 1536, 
                                                   1540, 1542, 1544, 1546, 1548, 1550, 1552, 1554, 1556, 1558, 
                                                   1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 
                                                   1570, 1572, 1574, 1576, 1578, 1580, 1582, 1584, 1586, 1588, 
                                                   1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 
                                                   1600, 1602, 1604, 1606, 1608, 1610, 1612, 1614, 1616, 1618, 
                                                   1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 
                                                   1630, 1633, 1636, 1639, 1642, 1645, 1648, 1651, 1654, 1657, 
                                                   1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 
                                                   1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 
                                                   1680, 1682, 1684, 1686, 1688, 1690, 1692, 1694, 1696, 1698, 
                                                   1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 
                                                   1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 
                                                   1720, 1722, 1724, 1726, 1728, 1730, 1732, 1734, 1736, 1738, 
                                                   1740, 1742, 1744, 1746, 1748, 1750, 1752, 1754, 1756, 1758, 
                                                   1760, 1762, 1764, 1766, 1768, 1770, 1772, 1774, 1776, 1778, 
                                                   1780, 1782, 1784, 1786, 1788, 1790, 1792, 1794, 1796, 1798, 
                                                   1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 
                                                   1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 
                                                   1820, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500
                                                   };
static uint8 cps_to_pwm_last_entry;

void Motor_Init()
{
    int ii;
    
    HB25_Enable_Pin_Write(HB25_DISABLE);
    
    // Initialize the balance of the array
    for (ii = MIN_CAL_ENTRY; ii < MAX_NUM_CAL_ENTRY; ++ii)
    {
        /* Need to figure out how to handle min/max for right motor case */
        cal_cps_to_pwm[ii].pwm = PWM_MIN;
        cal_cps_to_pwm[ii].cps = -1;
    }
    
    // Note: map_cps_to_pwm contains default pwm values and so it should not be initialized
    
    // Find the last non-stop value entry in the cps-to-pwm map
    for (ii = MAX_CPS_ENTRY; ii > MIN_CPS_ENTRY; --ii)
    {
        if (map_cps_to_pwm[ii] != PWM_STOP)
        {
            cps_to_pwm_last_entry = ii;
            break;
        }
    }
        
}

void Motor_Start()
{
    /* Enable the power on the HB-25 motor 
       Note: The HB-25 has a specific initialization sequence that is handled in hardware (see HB-25 reference).  All 
       that is necessary in software is to enable power to the HB-25 motor controller and start the PWM.  The PWM will 
       be enabled on to the HB-25 signal pin when initialization completes.
     */
    HB25_Enable_Pin_Write(HB25_ENABLE);    
    HB25_PWM_Start();
    Motor_SetOutput(0);
}

void Motor_SetOutput(int16 value)
/* Translate value, in millimeter per second to pwm via count/sec mapping
 */
{
    int16 cps;
    uint16 pwm;
    
    
    /* 
                 mm      count
          cps = ----- x -------
                 sec      mm
    */
    cps = abs(value * COUNT_PER_MILLIMETER);
    
    /* Constrain the CPS to the calibrated values */
    cps = constrain(cps, MIN_CPS_ENTRY, cps_to_pwm_last_entry);
    
    /* Note: PWM_REFLECT handles forward/reverse mapping and is defined appropriately for each board, i.e., BOARD_1,
       BOARD_2, and motor, i.e., LEFT_BOARD, RIGHT_BOARD
     */
    pwm = PWM_REFLECT(value, map_cps_to_pwm[cps]);
    
    HB25_PWM_WriteCompare(pwm);
}

void Motor_Stop()
{
    HB25_PWM_Stop();
    HB25_Enable_Pin_Write(HB25_DISABLE);
}

static int16 CalculateAverageCountPerSec(uint8 samples, uint16 delay)
{
    uint8 ii;
    int32 count_start;
    int32 count_end;
    int32 deltas = 0;
    
    for (ii = 0; ii < samples; ++ii)
    {
        count_start = (int32) Phase_Counter_ReadCounter();
        CyDelay(delay);
        count_end = (int32) Phase_Counter_ReadCounter();
        deltas += count_end - count_start;
    }
    deltas /= samples;
    return (deltas * MS_IN_SEC) / delay;
}

void Motor_Calibrate()
/* The purpose of calibration is to create a mapping between the speed of the motor (in count/sec) and the PWM
   value that produces the same speed and measured via the encoder.

   Calibration is performed in three steps:

    1. Run the motor over the range of PWM values, calculating the speed at each pwm sample, storing min/max pwm
       values for each count/sec calculation and the count/sec.
        Note: Limit the count/sec range to a usable range
    2. Calculate average pwm values from the min/max samples
    3. Linear interpolate between each marker

 */
{
    uint16 pwm;
    static int16 meas_cps;
    int ii;
    int jj;
    int cal_cps_index;
    int32 count_start;
    int32 count_end;
    int32 deltas;
    uint32 delay = 100;
    
    for (ii = 0; ii < MAX_CPS_ENTRY; ++ii)
    {
        map_cps_to_pwm[ii] = PWM_STOP;
    }
    
    cal_cps_index = 0;
    
    /* STEP 1.
        1. Run the motor from full forward to stop in steps of PWM_CAL_STEP
        2. At each step, calculate an average count/sec
    
        Note: This code works the same for both left and right motors in that forward is with respect to the robot even
              one more is actually running in reverse - just in case you get confused :-)
     */
    
    /* Allow the motor to spin up to full speed.
       Note: I don't understand why 1sec is needed.  When looking at the encoder pulses they appear to be accurate after
       several 100 milliseconds, but experimentally, I don't get accurate measurements until about 1sec.
       Fortunately, calibration is occassional.
     */
    HB25_PWM_WriteCompare(CAL_PWM_START);
    CyDelay(PWM_SETTLE_TIME);
    
    for (pwm = CAL_PWM_START; pwm > CAL_PWM_END; pwm += CAL_PWM_STEP)
    {   
        HB25_PWM_WriteCompare(pwm);
        /* Allow the motor to settle before measuing the speed.  Same thing here as above regarding how long.  Above
           the motor was stopped, here we're just changing the speed to be slightly slower.  I would have thought 100-
           200ms would be sufficient, but, again, 1sec gives the best and more accurate results.
         */
        CyDelay(PWM_SETTLE_TIME);

        deltas = 0;
        /* Measure the speed and calculate an average
           Note: Averaging the delta counts proved more consistent than averaging cps
         */
        for (ii = 0; ii < MAX_SPEED_SAMPLES; ++ii)
        {
            //meas_cps += CalculateAverageCountPerSec(250);
            
            count_start = (int32) Phase_Counter_ReadCounter();
            CyDelay(delay);
            count_end = (int32) Phase_Counter_ReadCounter();
            deltas += count_end - count_start;
        }
        deltas /= MAX_SPEED_SAMPLES;
        meas_cps = (deltas*MS_IN_SEC)/delay;
        
        // Constrain the measurement to the calibration range and store min/max pwm values
        if (meas_cps >= MIN_CPS_VALUE && meas_cps < MAX_CPS_VALUE)
        {   
            // If this is the first one or "new" one (cps != meas_cps) add a slot and set the values
            if (cal_cps_index < 0 || cal_cps_to_pwm[cal_cps_index].cps != meas_cps)
            {
                cal_cps_index++;
                cal_cps_to_pwm[cal_cps_index].cps = meas_cps;
                cal_cps_to_pwm[cal_cps_index].pwm = pwm;
            }
            // If this is a duplicate cps entry, overwrite it and we'll take care of that in interpolation
            else
            {
                cal_cps_to_pwm[cal_cps_index].pwm = pwm;
            }
        }        
    }
    
    HB25_PWM_WriteCompare(PWM_STOP);
    
    /* The first entry in the calibration array will always be where the motor stops, so set the min/max pwm values to
       PWM_STOP and also set the CPS to 0
     */
    cal_cps_to_pwm[cal_cps_index].pwm = PWM_STOP;
    cal_cps_to_pwm[cal_cps_index].cps = 0;

    /* 
        Capture the last (largest) cps entry       
     */
    cps_to_pwm_last_entry = cal_cps_to_pwm[0].cps;
            
    /* Linear interpolate the values 
        1. Loop over the markers array creating a delta, span and step between each sample
        2. Fill in the spaces between each sample with the interpolated values  
    */
    
    for (ii = cal_cps_index; ii > MIN_CAL_ENTRY + 1; --ii)
    {
        uint16 cps_i;
        uint16 cps_i_plus_1;
        
        cps_i = cal_cps_to_pwm[ii].cps;
        cps_i_plus_1 = cal_cps_to_pwm[ii+1].cps;
        
        // Get the ith and ith+1 samples
        int curr_pwm = map_cps_to_pwm[cps_i];
        int next_pwm = map_cps_to_pwm[cps_i_plus_1];
        
        // Calculate the delta
        int delta = next_pwm - curr_pwm;
        
        // Calculate the span between samples
        int span = cps_i_plus_1 - cps_i;
        
        // Calculate step for filling in blanks
        // Note: Use float so we benefit from round up
        float step = ((float) delta) / span;
        
        /*
            Example:
        
            cps         pwm     samples
            ...
            114
            115        1700        ith
            116      ->1702
            117      ->1704
            118      ->1705
            119      ->1708
            120        1710        ith + 1
            121
            ...
        
            Delta: 1710 - 1700 - 10
            Span:  120 - 115 = 5
            Step:  10 / 5 = 2
        
            Interpolated Values:
            jj start = cps[i] + 1 <= 116
            ...
            jj end   = cps[i+1]   < 120
         */        
        float value = curr_pwm;
        for (jj = cps_i + 1; jj < cps_i_plus_1; ++jj)
        {
            // Round up so we don't lose significant digits
            value = round(value + step);
            map_cps_to_pwm[jj] = (int) value;
        }
    }    
}

void Motor_ValidateCalibration()
{
    int ii;
    int16 meas_cps;
    int16 values[20] = {0};
    uint8 index = 0;
    
    
    /* The following code tests that each entry selects a pwm value and results in a matching count/s wheel speed 
     */
    
    Encoder_Reset();
    
    for (ii = CAL_VAL_CPS_START; ii <= cps_to_pwm_last_entry; ii += CAL_VAL_STEP)
    {
        HB25_PWM_WriteCompare(map_cps_to_pwm[ii]);
        CyDelay(PWM_SETTLE_TIME);
        
        meas_cps = CalculateAverageCountPerSec(CAL_VAL_NUM_SAMPLES, CAL_VAL_SAMPLE_PERIOD);
        
        /* Report via the serial port the commanded cps and the meas_cps
          Commanded       Measured
            <cps>   ->   <meas_cps>
         */
        values[index] = meas_cps;
        index++;
    }
    
    HB25_PWM_WriteCompare(PWM_STOP);      
}

void Motor_GetCalValues(int16** cal_values, uint16* num_entries)
{
    *cal_values = (int16 *) map_cps_to_pwm;
    *num_entries = cps_to_pwm_last_entry + 1;
}

/* [] END OF FILE */
